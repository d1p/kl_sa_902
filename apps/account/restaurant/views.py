from django.contrib.gis.geos import Point
from django.contrib.gis.db.models.functions import Distance
from django.contrib.gis.measure import D
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import mixins
from rest_framework.permissions import AllowAny
from rest_framework.viewsets import GenericViewSet, ReadOnlyModelViewSet, ModelViewSet

from apps.account.restaurant.filters import RestaurantTableFilter, RestaurantFilter
from apps.account.restaurant.models import Restaurant, Category, RestaurantTable
from apps.account.restaurant.serializers import (
    CategorySerializer,
    RestaurantSerializer,
    RestaurantTableSerializer,
    PublicRestaurantSerializer,
)
from utils.permission import IsAuthenticatedOrCreateOnly, IsRestaurantOwnerOrReadOnly


class RestaurantCategoryViewSet(ReadOnlyModelViewSet):
    """
    Return restaurant categories in ascending order.
    """

    permission_classes = [AllowAny]
    serializer_class = CategorySerializer
    queryset = Category.objects.all().order_by("name")


class RestaurantViewSet(
    GenericViewSet,
    mixins.CreateModelMixin,
    mixins.UpdateModelMixin,
    mixins.RetrieveModelMixin,
    mixins.ListModelMixin,
):
    """
    to search and filter stores by users geolocation add "lat", "lng" in the url get params.
    Example:
        url :/api/restaurant/?lat=32.1231&lng=32.4452
    #### Note
    geolocation = { "latitude": Latitude, "longitude": Longitude }
    """

    permission_classes = [IsAuthenticatedOrCreateOnly]

    def get_queryset(self):
        request = self.request
        radius = request.GET.get("radius", 100)

        if (
            request.GET.get("lat", None) is not None
            and request.GET.get("lng", None) is not None
        ):
            point = Point(
                float(request.GET.get("lng")), float(request.GET.get("lat")), srid=4326
            )
            return (
                Restaurant.objects.filter(
                    is_public=True, geolocation__distance_lte=(point, D(km=radius))
                )
                .annotate(distance=Distance("geolocation", point))
                .order_by("distance")
            )
        return Restaurant.objects.filter(is_public=True)

    def get_serializer_class(self):
        if self.request.user.is_superuser:
            return RestaurantSerializer

        if self.action in ["list", "geo_list"]:
            return PublicRestaurantSerializer
        elif self.action in ("create", "update", "destroy"):
            return RestaurantSerializer
        else:
            try:
                instance = self.get_object()
                if instance.user.id != self.request.user.id:
                    return PublicRestaurantSerializer
                else:
                    return RestaurantSerializer
            except AssertionError:
                return PublicRestaurantSerializer

    lookup_field = "user"
    filter_backends = [DjangoFilterBackend]
    filterset_class = RestaurantFilter


class RestaurantTableViewSet(ModelViewSet):
    """
    Returns http 204 No Content upon successful delete
    TABLE QR CODES ARE GENERATED BY BACKGROUND WORKER.
    So after creating a new table, Wait for QR code generation .
    """

    serializer_class = RestaurantTableSerializer
    permission_classes = [IsRestaurantOwnerOrReadOnly]
    filter_backends = [DjangoFilterBackend]
    filterset_class = RestaurantTableFilter

    def get_queryset(self):
        if self.action in ["update", "create", "delete"]:
            return RestaurantTable.objects.filter(
                is_active=True, user=self.request.user
            )
        return RestaurantTable.objects.filter(is_active=True)

    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(user=user)

    def perform_update(self, serializer):
        serializer.save()

    def perform_destroy(self, instance):
        instance: RestaurantTable = self.get_object()
        instance.is_active = False
        instance.save()
