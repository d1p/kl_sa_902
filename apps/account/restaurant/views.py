from decimal import Decimal

from django.contrib.auth.decorators import login_required
from django.contrib.gis.db.models.functions import Distance
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D
from django.core.exceptions import PermissionDenied
from django.db.models import Sum
from django.shortcuts import get_object_or_404, render
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import mixins
from rest_framework.permissions import AllowAny
from rest_framework.viewsets import GenericViewSet, ReadOnlyModelViewSet, ModelViewSet

from apps.account.restaurant.filters import RestaurantTableFilter, RestaurantFilter
from apps.account.restaurant.forms import PayableDetailsSearchForm
from apps.account.restaurant.models import Restaurant, Category, RestaurantTable
from apps.account.restaurant.serializers import (
    CategorySerializer,
    RestaurantSerializer,
    RestaurantTableSerializer,
    PublicRestaurantSerializer,
)
from apps.order.invoice.models import Invoice
from apps.order.types import OrderType
from utils.permission import IsAuthenticatedOrCreateOnly, IsRestaurantOwnerOrReadOnly


class RestaurantCategoryViewSet(ReadOnlyModelViewSet):
    """
    Return restaurant categories in ascending order.
    """

    permission_classes = [AllowAny]
    serializer_class = CategorySerializer
    queryset = Category.objects.all().order_by("name")


class RestaurantViewSet(
    GenericViewSet,
    mixins.CreateModelMixin,
    mixins.UpdateModelMixin,
    mixins.RetrieveModelMixin,
    mixins.ListModelMixin,
):
    """
    to search and filter stores by users geolocation add "lat", "lng" in the url get params.
    Example:
        url :/api/restaurant/?lat=32.1231&lng=32.4452
    #### Note
    geolocation = { "latitude": Latitude, "longitude": Longitude }
    """

    permission_classes = [IsAuthenticatedOrCreateOnly]

    def get_queryset(self):
        request = self.request
        radius = request.GET.get("radius", 300)

        if (
                request.GET.get("lat", None) is not None
                and request.GET.get("lng", None) is not None
        ):
            point = Point(
                float(request.GET.get("lng")), float(request.GET.get("lat")), srid=4326
            )
            return (
                Restaurant.objects.filter(
                    is_public=True, geolocation__distance_lte=(point, D(km=radius))
                )
                    .annotate(distance=Distance("geolocation", point))
                    .order_by("distance")
            )
        return Restaurant.objects.filter(is_public=True)

    def get_serializer_class(self):
        if self.request.user.is_superuser:
            return RestaurantSerializer

        if self.action in ["list", "geo_list"]:
            return PublicRestaurantSerializer
        elif self.action in ("create", "update", "destroy"):
            return RestaurantSerializer
        else:
            try:
                instance = self.get_object()
                if instance.user.id != self.request.user.id:
                    return PublicRestaurantSerializer
                else:
                    return RestaurantSerializer
            except AssertionError:
                return PublicRestaurantSerializer

    lookup_field = "user"
    filter_backends = [DjangoFilterBackend]
    filterset_class = RestaurantFilter


class RestaurantTableViewSet(ModelViewSet):
    """
    Returns http 204 No Content upon successful delete
    TABLE QR CODES ARE GENERATED BY BACKGROUND WORKER.
    So after creating a new table, Wait for QR code generation .
    """

    serializer_class = RestaurantTableSerializer
    permission_classes = [IsRestaurantOwnerOrReadOnly]
    filter_backends = [DjangoFilterBackend]
    filterset_class = RestaurantTableFilter

    def get_queryset(self):
        if self.action in ["update", "create", "delete"]:
            return RestaurantTable.objects.filter(
                is_active=True, user=self.request.user
            )
        return RestaurantTable.objects.filter(is_active=True)

    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(user=user)

    def perform_update(self, serializer):
        serializer.save()

    def perform_destroy(self, instance):
        instance: RestaurantTable = self.get_object()
        instance.is_active = False
        instance.save()


@login_required
def report_view(request, user_id: int):
    if request.user.is_superuser is False:
        raise PermissionDenied
    restaurant = get_object_or_404(Restaurant, user__id=user_id)

    form = PayableDetailsSearchForm()

    if request.method == "POST":
        form = PayableDetailsSearchForm(request.POST)
        if form.is_valid():
            from_date = form.cleaned_data.get("from_date")
            to_date = form.cleaned_data.get("to_date")

            inhouse = Invoice.objects.filter(
                order__restaurant=restaurant.user,
                order__payment_completed=True,
                order__order_type=OrderType.IN_HOUSE,
                created_at__date__gte=from_date,
                created_at__date__lte=to_date,
            ).aggregate(Sum("app_earning"), Sum("restaurant_earning"))

            pickup = Invoice.objects.filter(
                order__restaurant=restaurant.user,
                order__payment_completed=True,
                order__order_type=OrderType.PICK_UP,
                created_at__date__gte=from_date,
                created_at__date__lte=to_date,
            ).aggregate(Sum("app_earning"), Sum("restaurant_earning"))

            inhouse_app_earnings = inhouse["app_earning__sum"] if inhouse["app_earning__sum"] is not None else Decimal(
                0)
            pickup_app_earnings = pickup["app_earning__sum"] if pickup["app_earning__sum"] is not None else Decimal(0)

            app_total = inhouse_app_earnings + pickup_app_earnings

            inhouse_restaurant_earnings = inhouse["restaurant_earning__sum"] if inhouse[
                                                                                    "restaurant_earning__sum"] is not None else Decimal(
                0)
            pickup_restaurant_earnings = pickup["restaurant_earning__sum"] if pickup[
                                                                                  "restaurant_earning__sum"] is not None else Decimal(
                0)

            restaurant_total = inhouse_restaurant_earnings + pickup_restaurant_earnings

            pickup_count = Invoice.objects.filter(
                order__restaurant=restaurant.user,
                order__payment_completed=True,
                order__order_type=OrderType.PICK_UP,
                created_at__date__gte=from_date,
                created_at__date__lte=to_date,
            ).count()
            inhouse_count = Invoice.objects.filter(
                order__restaurant=restaurant.user,
                order__payment_completed=True,
                order__order_type=OrderType.IN_HOUSE,
                created_at__date__gte=from_date,
                created_at__date__lte=to_date,
            ).count()

            return render(request, "restaurant/report.html",
                          {"restaurant": restaurant,
                           "form": form,
                           "inhouse_app_earnings": inhouse_app_earnings,
                           "pickup_app_earnings": pickup_app_earnings,
                           "inhouse_restaurant_earnings": inhouse_restaurant_earnings,
                           "pickup_restaurant_earnings": pickup_restaurant_earnings,
                           "pickup": pickup,
                           "app_total": app_total,
                           "restaurant_total": restaurant_total,
                           "pickup_count": pickup_count,
                           "inhouse_count": inhouse_count,
                           "total_orders": inhouse_count + pickup_count})

    return render(request, "restaurant/report.html", {"restaurant": restaurant, "form": form, "get": True})
